// ABSTRACT BASE CLASSES FOR WEAPONS AND WORLDWEAPONS
//~===================================================~

//how far your arms can reach, in map units
const DOSO_ARMSREACH = 18;
//how wide the grip is by default (one hand)
const DOSO_HANDWIDTH = 3.0;
//maximum yaw deviation from front of your weapon
const DOSO_MAXANGLE = 90.0;
//lowest pitch of your weapon
const DOSO_MAXPITCH = 70.0;
//highest pitch of your weapon
const DOSO_MINPITCH =-85.0;

//base class from which weapon items will inherit
class doso_weap:weapon abstract{
	class<doso_weap_w> worldwpn;	//the world weapon to spawn in world!
	
	vector2 initangle;	//the readied angle to initialize to
	vector3 initpos;	//the readied position to initialize to
	
	property world:worldwpn;
	property angle:initangle;
	property pos:initpos;
	
	default{
		doso_weap.world "doso_weap_w";
		//angle and pos of all zero is considered to be straight ahead and pointed out; ie, a fuck-off stance
		doso_weap.angle (0.0, 0.0);
		doso_weap.pos (0.0, 0.0, 0.0);
	}
	
	doso_weap_w child;
	vector2 wpnangle;
	vector3 wpnpos;
	
	const SENS_SWINGTRA = 0.3;
	const SENS_SWINGANG = 1.6;
	const SENS_MOVE		= 0.5;
	const SENS_ROTATE	= 1.0;
	
	void rotatew(float x,float y){
		wpnangle -= (x*SENS_ROTATE,y*SENS_ROTATE);
		
		boundw();
	}
	void swingw(float x,float y){
		wpnpos += (0.0,-x*SENS_SWINGTRA,y*SENS_SWINGTRA);
		wpnangle -= (x*SENS_SWINGANG,y*SENS_SWINGANG);
		
		boundw();
	}
	void movew(float x,float y){
		wpnpos += (y*SENS_MOVE,-x*SENS_MOVE,0.0);
		
		boundw();
	}
	
	//ensure the weapon is within its allowed boundries
	void boundw(){
		if(wpnpos.x< -(child.maxextend))
			wpnpos.x = -(child.maxextend);
		if(wpnpos.x> DOSO_ARMSREACH + (child.maxextend))
			wpnpos.x = DOSO_ARMSREACH + (child.maxextend);
		
		if(wpnpos.y> DOSO_ARMSREACH)
			wpnpos.y = DOSO_ARMSREACH;
		if(wpnpos.y< -DOSO_ARMSREACH)
			wpnpos.y = -DOSO_ARMSREACH;
		
		if(wpnpos.z> DOSO_ARMSREACH)
			wpnpos.z = DOSO_ARMSREACH;
		if(wpnpos.z< -DOSO_ARMSREACH)
			wpnpos.z = -DOSO_ARMSREACH;
		
		if(wpnangle.x> DOSO_MAXANGLE)
			wpnangle.x = DOSO_MAXANGLE;
		if(wpnangle.x< -DOSO_MAXANGLE)
			wpnangle.x = -DOSO_MAXANGLE;
		
		if(wpnangle.y> DOSO_MAXPITCH)
			wpnangle.y = DOSO_MAXPITCH;
		if(wpnangle.y< DOSO_MINPITCH)
			wpnangle.y = DOSO_MINPITCH;
	}
	
	states{
	spawn:
		TNT1 A -1;
		stop;
	select:
		TNT1 A 0 {
			invoker.child = doso_weap_w.create(invoker.worldwpn,invoker);
			invoker.wpnangle = invoker.initangle;
			invoker.wpnpos = invoker.initpos;
		}
		TNT1 A 1 A_Raise();
		wait;
	deselect:
		TNT1 A 0 {
			invoker.child.destroy();
		}
		TNT1 A 1 A_Lower();
		wait;
	ready:
		TNT1 A 1 A_WeaponReady(WRF_NOFIRE|WRF_ALLOWRELOAD);
		loop;
	fire:
		TNT1 A 0;
		goto ready;
	reload:
		TNT1 A 2 {
			invoker.wpnangle = invoker.initangle;
			invoker.wpnpos = invoker.initpos;
		}
		goto ready;
	}
}

//base class from which held weapons in-world will inherit
class doso_weap_w:actor abstract{
	//here goes property variables and defaults
	double wpnmass;	//mass in kg
	uint8 massdist;	//how far out of 255 along the weapon's length the center of mass is
	double massgrad;//how much the mass fluctuates along the length, 0.0 = 100% mass everywhere, 1.0 = 200% at center, 0% at max dist
	
	uint8 bladecov;	//how much out of 255 of the weapon that is bladed (from the tip to the hands)
	uint8 bladestrt;//if non-zero, where the blade part of the weapon starts (from the tip to the hands)
	
	//note for sharpness: haft is considered to be 0.1 sharpness, which would need considerable force to wound.
	double tipsharp;//how sharp the tip of the weapon is. if 0, deemed to be unable to wound; if 1, deemed to be *very* thin/sharp
	double bldsharp;//how sharp the blade is. if 0, deemed to be blunt and unable to wound; if 1, deemed to be very fine and sharp
	
	uint wpnsize;	//length of the weapon in doom map units
	uint wpnwidth;	//width of the weapon, of course, in doom map units
	uint bladewidth;//width of the weapon's bladed segment, again in dmu
	
	uint8 maxextend;//how much farther beyond arm's length the weapon can be extended
	float restdist;	//how far from the player the weapon rests
	
	name wpnsprite;	//pretty self explanatory. weapons can change these on the fly if they really want to.
	
	property mass:wpnmass,massdist,massgrad;
	property blade:bladecov,bladewidth;
	property bladestart:bladestrt;
	property size:wpnsize,wpnwidth;
	property sharpness:tipsharp,bldsharp;
	property maxextend:maxextend;
	property restdistance:restdist;
	property sprite:wpnsprite;
	
	default{
		+INTERPOLATEANGLES
		+FLATSPRITE
		+ROLLSPRITE
		+NOCLIP
		+NOGRAVITY
		-SOLID
		
		//doso_weap_w defaults
		//default is basically a brick
		doso_weap_w.mass 1.0,128,0.0;
		doso_weap_w.blade 0,8;
		doso_weap_w.bladestart 0;
		doso_weap_w.size 24,8;
		doso_weap_w.sharpness 0.15,0.15;
		doso_weap_w.maxextend 1;
		doso_weap_w.restdistance 0;
		doso_weap_w.sprite 'tnt1';
	}
	
	//here goes logic variables and code
	doso_weap parent;
	halfsworder owner;
	
	static doso_weap_w Create(class<doso_weap_w> classname,doso_weap parent){
		doso_weap_w this = doso_weap_w(spawn(classname,parent.owner.pos + (0.0, 0.0, parent.owner.height/2),ALLOW_REPLACE));
		this.parent = parent;
		this.owner = halfsworder(parent.owner);
		this.angle = parent.owner.angle;
		this.pitch = parent.owner.pitch;
		this.changesprite();
		
		doso_bloodstain.create(this);
		return this;
	}
	
	//return how much of the weapon's extension is being used, it's just distance from player - arm length
	float weaponextension(){
		return max(0,(distance2d(owner) - (restdist - 8)) - DOSO_ARMSREACH);
	}
	//return the mass at a given point along the weapon in dmu
	double massatpoint(double dist){
		double comradius = wpnsize*(massdist/255.0);
		//distance from center of mass in multiples of wpnsize
		double distfromcom = abs(comradius - dist)/wpnsize;
		//center it on zero
		distfromcom -= 0.5;
		
		double masshere = wpnmass;
		double maxdev = 1.0*massgrad;
		return masshere * (1.0 - maxdev*distfromcom);
	}
	
	//draw particles for a linetrace's start and end.
	static void drawlineparticles(in flinetracedata ln){
		fspawnparticleparams particle;
		particle.startalpha = 0.5;
		particle.size = 4.;
		particle.lifetime = 1;
		particle.flags = SPF_FULLBRIGHT|SPF_REPLACE;
		
		particle.color1 = color(255,255,0);
		if(ln.hittype!=TRACE_HITNONE)
			particle.color1 = color(255,0,0);
		particle.pos = ln.hitlocation;
		level.spawnparticle(particle);
		
		particle.color1 = color(127,255,0);
		particle.pos -= ln.hitdir * ln.distance;
		level.spawnparticle(particle);
	}
	
	//map units per tic squared at 1kg
	const POS_MAXACCEL = 5.5;
	//degrees per tic squared at 1kg and radius 32 (something like one meter)
	//and with a grip radius of 5
	const ANG_MAXACCEL = 16.0;
	//velocities multiplied by these every tic
	const P_DECCEL_COEFF = 0.7;
	const A_DECCEL_COEFF = 0.85;
	
	vector3 desired_position;
	double desired_angle;
	double desired_pitch;
	
	vector2 vel_angle;
	
	override void Tick(){
		super.tick();
		
		//delete if no longer selected for some reason
		if(owner.player.readyweapon!=parent || !parent.owner)
			destroy();
		
		//spawn the marker at the desired position
		doso_marker.create(restdist,parent);
		
		//set the desired position and angle
		vector2 rotofs = RotateVector(parent.wpnpos.xy + (8.0 + restdist, 0.0),owner.angle);
		vector3 wpnofs = (rotofs.x, rotofs.y, parent.wpnpos.z);
		desired_position = owner.pos + (0.0, 0.0, owner.height/2) + wpnofs;
		
		desired_angle = normalize180(owner.angle + parent.wpnangle.x);
		desired_pitch = parent.wpnangle.y;
		//I wanted to affect the roll to fix the issue of the weapon not quite looking like it's directed toward the
		//line in front of the player but roll doesn't work as I expected it to here so whatever
		
		//now to actually accelerate towards this desired state
		
		//first accelerate pos
		vel *= P_DECCEL_COEFF;
		if(level.vec3diff(pos,desired_position).length()>1){
			double force = POS_MAXACCEL;
			if(wpnmass!=0)
				force /= wpnmass;
			//turn this desired vector into a unit vector and then multiply it by POS_MAXACCEL
			vector3 movevec = level.vec3diff(pos,desired_position);
			//if in thrust mode, exert more force.
			if(owner.player.buttons & BT_ALTATTACK)
				force *= 2.;
			//hesitate a bit if too close. this is supposed to prevent overshoots and I *think* it works
			if(movevec.length()<(force/P_DECCEL_COEFF)*2){
				float dist = movevec.length();
				dist /= (force/P_DECCEL_COEFF)*2;
				force *= dist;
			}
			//if we're farther than the arm's length + the weapon's available extension, pull much harder
			if(weaponextension()>=maxextend*1.5){
				force *= 1.05 + (weaponextension() - maxextend*1.5)/90;
				if(distance2d(owner)>(DOSO_ARMSREACH + maxextend)*3.){
					force = 0.;
					SetOrigin(parent.owner.pos + (0.0, 0.0, parent.owner.height/2),true);
				}
			}
			movevec /= movevec.length();
			movevec *= force;
			vel += movevec;
		}
		
		//then accelerate angle
		vel_angle *= A_DECCEL_COEFF;
		//here we have to do some more fancy stuff, involving moment of inertia and torque.
		//torque is simply going to be our initial acceleration assuming MoI of one.
		//we will be doing a very crude approximation by simply multipliying mass by radius squared.
		//hopefully this works well enough.
		if((deltaangle(angle,desired_angle),deltaangle(pitch,desired_pitch)).length()>6){
			double torque = ANG_MAXACCEL;
			//calculate radius of our grip from our pivot point.
			float gripwidth = DOSO_HANDWIDTH + max(0,maxextend - weaponextension());
			//torque is multiplied by grip width divided down so that torque is unchanged for a grip width of 5 units
			torque *= gripwidth/5;
			//we divide CoM radius by 32 to get it in something resembling meters.
			double comradius = (wpnsize*(massdist/255.0)/32);
			double momentinertia = wpnmass * comradius * comradius;
			if(momentinertia!=0)
				torque /= momentinertia;
			else
				console.printf("moment of inertia for weapon is zero!");
			vector2 movevec = (deltaangle(angle,desired_angle),deltaangle(pitch,desired_pitch));
			if(movevec.length()<(torque/A_DECCEL_COEFF)*8){
				float dist = movevec.length();
				dist /= (torque/A_DECCEL_COEFF)*8;
				torque *= dist;
			}
			movevec /= movevec.length();
			movevec *= torque;
			vel_angle += movevec;
		}
		angle += vel_angle.x;
		pitch += vel_angle.y;
		
		//now for collision detection.
		flinetracedata line_center;
		flinetracedata line_haft_l;
		flinetracedata line_haft_r;
		flinetracedata line_blad_l;
		flinetracedata line_blad_r;
		flinetracedata line_spik_l;
		flinetracedata line_spik_r;
		
		double haft_len;
		double blad_start;
		double blad_len;
		double spik_start;
		double spik_len;
		
		vector2 ofs_xy;
		vector2 ofs_z;
		vector3 lineoffset;
		
		//disable the owner's solidity before tests and reenable it after.
		owner.bsolid = false;
		owner.bshootable = false;
		
		//center line
		LineTrace(angle,wpnsize,pitch,TRF_NOSKY|TRF_SOLIDACTORS,data:line_center);
		//for some fucked off dumbass reason the fucking lines refuse to offset in any way that I want them to
		//so center line it is.
		
		//owner become solid again.
		owner.bsolid = true;
		owner.bshootable = true;
		
		//draw some debug particles for me
		if(doso_debug){
			drawlineparticles(line_center);
		}
		if(line_center.hittype!=TRACE_HITNONE){
			wpncollide(line_center);
		}
		
		//drip blood!
		trydripblood();
	}
	
	//if the weapon has collided with something, we run this function
	virtual void wpncollide(in flinetracedata ln){
		//SetOrigin(pos - vel,false);
		angle -= vel_angle.x;
		pitch -= vel_angle.y;
		if(ln.hittype==TRACE_HITACTOR){
			float vel_p = vel.length();
			float vel_a = (vel_angle.length() * (3.1415/180))*ln.distance;
			
			float impact_vel = vel_p + vel_a;
			
			vel *= 0.015;
			vel_angle *= 0.2;
			
			impact_vel /= 32.; //meters/tic
			impact_vel *= 35.; //meters/sec
			
			float force = impact_vel * massatpoint(ln.distance);
			
			if(impact_vel > 12. && doso_debug)
				A_Log(string.format(gettag().." struck "..ln.hitactor.gettag().." with net speed of %.1f m/s and mass of %.2fkg with a force of %dN",impact_vel,massatpoint(ln.distance),force));
			
			if(ln.hitactor.bshootable)
				hitactor(ln.hitactor,force,ln.distance,ln.hitlocation);
		}else{
			if( (vel.length(),vel_angle.length()).length() > 12. ){
				for(int i=1;i< floor((vel.length(),vel_angle.length()).length()*2 - 18);i++){
					fspawnparticleparams prt;
					prt.color1 = color(255,191,0);
					prt.pos = ln.hitlocation;
					prt.vel = (frandom(-5.,5.),frandom(-5.,5.),frandom(2.,9.));
					prt.accel = (0.,0.,-1.);
					prt.size = 2;
					prt.lifetime = 10;
					prt.startalpha = 0.7;
					prt.flags = SPF_FULLBRIGHT;
					level.SpawnParticle(prt);
				}
			}
			vector2 normal;
			vector3 normal3;
			double sep;
			switch(ln.hittype){
				case TRACE_HITWALL:
					normal = doso_math.vec2normal(ln.hitline.delta);
					normal3 = (normal.x,normal.y,0.);
					sep = vel dot normal3;
					if(sep < 0){
						vel -= sep * normal;
					}
					break;
				case TRACE_HITFLOOR:
					normal3 = (0.,0.,1.);
					sep = vel dot normal3;
					if(sep < 0){
						vel -= sep * normal3;
					}
					break;
				case TRACE_HITCEILING:
					normal3 = (0.,0.,-1.);
					sep = vel dot normal3;
					if(sep < 0){
						vel -= sep * normal3;
					}
					break;
				default:
					vel = (0.,0.,0.);
					break;
			}
			vel_angle = (0.,0.);
		}
	}
	
	//hit this actor
	virtual void hitactor(actor hit,float force,double wpnpos,vector3 hitpos){
		double sharpness = 0.1;
		float bladestart = wpnsize * (1.0 - ((bladestrt + bladecov) / 255.));
		float bladeend = wpnsize * (1.0 - ((bladestrt) / 255.));
		bool hitblade;
		bool hitpoint;
		
		if(wpnpos > bladestart && wpnpos < bladeend)
			hitblade = true;
		if(wpnsize - wpnpos < (wpnwidth+1)*tipsharp){
			hitpoint = true;
			hitblade = false;
			force *= 1.7 + tipsharp;
		}
		
		hit.vel += (vel / (hit.mass/wpnmass)) * (hitpoint?3.:2.);
		
		if(hitblade){
			if(doso_debug && force > 30)
				A_Log("hit: blade");
			sharpness = bldsharp;
		}
		if(hitpoint){
			if(doso_debug && force > 30)
				A_Log("hit: tip");
			sharpness = tipsharp;
		}
		if(!(hitblade || hitpoint) && doso_debug && force > 30)
			A_Log("hit: haft");
		
		float bluntdmg = (((force - 5.) * (1.0 - sharpness + 0.1)) ** 1.4) * 0.1;
		float sharpdmg = ((force + 2) * sharpness) ** 0.8;
		bluntdmg *= 0.5;
		if(hitpoint){
			bluntdmg *= 0.6;
			//thinner spike = deeper thrust = more damage
			//applies more to sharper points so as to not apply to, say, a quarterstaff
			sharpdmg *= 0.9 + ((1.0 / min(wpnwidth,bladewidth)) * tipsharp);
		}
		if(!(hitblade || hitpoint)){
			bluntdmg *= 0.7;
			sharpdmg *= 0.85;
		}
		
		int totdmg = bluntdmg + sharpdmg;
		//discard collisions too light as they're probably just clang anyway
		if(totdmg < 5 || (force < 10 && !hitpoint))
			return;
		if(doso_debug)
			A_Log(string.format("total strike dmg: %d (%d blunt, %d sharp)",totdmg,bluntdmg,sharpdmg));
		int bloodpartcl = sharpdmg + bluntdmg/5;
		if(hit.bnoblood)
			bloodpartcl = -1;
		if(totdmg > hit.health)
			bloodpartcl = bloodpartcl * 4 + 8;
		if(bloodpartcl>6){
			for(int i=1;i<bloodpartcl;i++){
				fspawnparticleparams prt;
				prt.color1 = color(0x66,0,0);
				prt.pos = hitpos;
				prt.vel = (frandom(-2.,2.),frandom(-2.,2.),frandom(-1.,1.)) * (1.0 + i/50);
				prt.accel = (0.,0.,-.8);
				prt.size = random(4,12) + floor(i/4);
				prt.lifetime = random(10,16) + i;
				prt.startalpha = 0.9;
				level.SpawnParticle(prt);
			}
		}
		for(int i=0;i<=2;i++){
			if(blood[i].blood==0){
				blood[i].blood = bloodpartcl/2;
				blood[i].timer = 1;
				blood[i].weappos = wpnpos;
				break;
			}
			if(i==2){
				blood[random(0,2)].blood += bloodpartcl/2;
			}
		}
		vector3 diff = level.vec3diff(pos,hitpos);
		SetOrigin(hitpos,false);
		hit.damagemobj(self,owner,bluntdmg,"blunt");
		hit.damagemobj(self,owner,sharpdmg,"blade");
		SetOrigin(pos-diff,false);
	}
	
	//blood drip stuff
	blooddripspot blood[3];
	void TryDripBlood(){
		for(int i=0;i<=2;i++){
			if(blood[i].blood > 0){
				blood[i].timer--;
				if(vel_angle.length()>6){
					blood[i].timer -= vel_angle.length()/2;
				}
				if(blood[i].timer<=0){
					blood[i].timer = 44 - blood[i].blood;
					blood[i].blood--;
					
					//calculate bonus velocity from angular movement
					vector2 vel_a = ((vel_angle.x * (3.1415/180))*blood[i].weappos,(vel_angle.y * (3.1415/180))*blood[i].weappos);
					vector2 vel_a_xy = angletovector(deltaangle(angle,random(-165,-75)),vel_a.x);
					vector3 vel_a_transfer = (vel_a_xy.x,vel_a_xy.y,vel_a.y);
					
					fspawnparticleparams prt;
					prt.color1 = color(0x66,0,0);
					vector2 ofz = angletovector(pitch,blood[i].weappos);
					vector2 ofxy = angletovector(angle,1.);
					vector3 bloodpos = (ofxy.x * ofz.x, ofxy.y * ofz.x, -ofz.y);
					prt.pos = pos + bloodpos;
					prt.vel = (frandom(-1.,1.),frandom(-1.,1.),frandom(-1.,0.5)) + vel + vel_a_transfer;
					prt.accel = (0.,0.,-.6);
					prt.size = random(4,4+blood[i].blood/2);
					prt.lifetime = random(10,16);
					prt.startalpha = 0.9;
					level.SpawnParticle(prt);
					//spawn more particles if you're swinging fast
					if(vel_angle.length()>8){
						//A_Log("splash blood");
						prt.vel = (frandom(-1.,1.),frandom(-1.,1.),frandom(-1.,0.5)) + vel + vel_a_transfer;
						prt.size = random(4,4+blood[i].blood/2);
						level.SpawnParticle(prt);
						if(vel_angle.length()>16){
							prt.vel = (frandom(-1.,1.),frandom(-1.,1.),frandom(-1.,0.5)) + vel + vel_a_transfer * 1.3;
							level.SpawnParticle(prt);
							prt.vel = (frandom(-1.,1.),frandom(-1.,1.),frandom(-1.,0.5)) + vel + vel_a_transfer * 1.2;
							prt.size = random(4,4+blood[i].blood/2);
							level.SpawnParticle(prt);
							blood[i].blood--;
							blood[i].timer-=6;
						}
					}
				}
			}
		}
	}
	
	void ChangeSprite(name spritename = "null"){
		if(spritename=="null"){
			spritename = default.wpnsprite;
		}
		wpnsprite = spritename;
		sprite = GetSpriteIndex(wpnsprite);
	}
	
	states{
	spawn:
		#### Z 1;
		loop;
	}
}


//desired position marker
class doso_marker:actor{
	default{
		+INTERPOLATEANGLES
		+FLATSPRITE
		+ROLLSPRITE
		+NOCLIP
		+NOGRAVITY
		-SOLID
		
		//+BRIGHT
		
		renderstyle "add";
		alpha 0.5;
	}
	
	static void Create(float restdist,doso_weap parent){
		if(!parent || !parent.owner)
			return;
		restdist-=1;
		vector2 rotofs = RotateVector(parent.wpnpos.xy + (8.0 + restdist, 0.0),parent.owner.angle);
		vector3 wpnofs = (rotofs.x, rotofs.y, parent.wpnpos.z+1);
		doso_marker this = doso_marker(spawn("doso_marker",parent.owner.pos + (0.0, 0.0, parent.owner.height/2) + wpnofs,ALLOW_REPLACE));
		
		this.angle = parent.owner.angle + parent.wpnangle.x;
		this.pitch = parent.wpnangle.y;
	}
	
	states{
	spawn:
		LINE Y 2;
		stop;
	}
}

//struct for blood drippers
struct blooddripspot{
	int blood;
	float weappos;
	int timer;
};
//class for bloody weapon overlays
class doso_bloodstain:actor{
	default{
		+INTERPOLATEANGLES
		+FLATSPRITE
		+ROLLSPRITE
		+NOCLIP
		+NOGRAVITY
		-SOLID
		+NOBLOCKMAP
		+BRIGHT
		
		renderstyle "multiply";
	}
	doso_weap_w parent;
	uint8 bloodthreshold;
	uint8 bloodi;
	static doso_bloodstain CreateOne(doso_weap_w parent){
		doso_bloodstain this = doso_bloodstain(spawn("doso_bloodstain",parent.pos));
		this.parent = parent;
		this.sprite = parent.sprite;
		this.angle = parent.angle;
		this.pitch = parent.pitch;
		this.roll = parent.roll;
		this.A_FadeTo(0.0,FTF_CLAMP);
		
		return this;
	}
	const MAXBLOOD = 6;
	static void Create(doso_weap_w parent){
		doso_bloodstain this;
		
		for(int i = 1;i<=MAXBLOOD;i++){
			this = doso_bloodstain.createone(parent);
			this.bloodthreshold = 10*i;
		}
	}
	
	override void tick(){
		super.tick();
		
		if(!parent)destroy();
		
		SetOrigin(parent.pos,true);
		sprite = parent.sprite;
		angle = parent.angle;
		pitch = parent.pitch;
		roll = parent.roll;
		alpha = 0.0;
		
		int blood = 0;
		
		for(int i = 0;i <= 2;i++){
			blood += parent.blood[i].blood;
		}
		
		if(blood > bloodthreshold){
			alpha = 1.0;
		}
	}
	
	states{
	spawn:
		#### Y 1;
		loop;
	}
}