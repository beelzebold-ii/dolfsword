// ABSTRACT BASE CLASSES FOR WEAPONS AND WORLDWEAPONS
//~===================================================~

//how far your arms can reach, in map units
const DOSO_ARMSREACH = 18;
//maximum yaw deviation from front of your weapon
const DOSO_MAXANGLE = 90.0;
//lowest pitch of your weapon
const DOSO_MAXPITCH = 70.0;
//highest pitch of your weapon
const DOSO_MINPITCH =-85.0;

//base class from which weapon items will inherit
class doso_weap:weapon abstract{
	class<doso_weap_w> worldwpn;	//the world weapon to spawn in world!
	
	vector2 initangle;	//the readied angle to initialize to
	vector3 initpos;	//the readied position to initialize to
	
	property world:worldwpn;
	property angle:initangle;
	property pos:initpos;
	
	default{
		doso_weap.world "doso_weap_w";
		//angle and pos of all zero is considered to be straight ahead and pointed out; ie, a fuck-off stance
		doso_weap.angle (0.0, 0.0);
		doso_weap.pos (0.0, 0.0, 0.0);
	}
	
	doso_weap_w child;
	vector2 wpnangle;
	vector3 wpnpos;
	
	const SENS_SWINGTRA = 0.3;
	const SENS_SWINGANG = 1.6;
	const SENS_MOVE		= 0.5;
	const SENS_ROTATE	= 1.0;
	
	void rotatew(float x,float y){
		wpnangle -= (x*SENS_ROTATE,y*SENS_ROTATE);
		
		boundw();
	}
	void swingw(float x,float y){
		wpnpos += (0.0,-x*SENS_SWINGTRA,y*SENS_SWINGTRA);
		wpnangle -= (x*SENS_SWINGANG,y*SENS_SWINGANG);
		
		boundw();
	}
	void movew(float x,float y){
		wpnpos += (y*SENS_MOVE,-x*SENS_MOVE,0.0);
		
		boundw();
	}
	
	//ensure the weapon is within its allowed boundries
	void boundw(){
		if(wpnpos.x< -(child.maxextend))
			wpnpos.x = -(child.maxextend);
		if(wpnpos.x> DOSO_ARMSREACH + (child.maxextend))
			wpnpos.x = DOSO_ARMSREACH + (child.maxextend);
		
		if(wpnpos.y> DOSO_ARMSREACH)
			wpnpos.y = DOSO_ARMSREACH;
		if(wpnpos.y< -DOSO_ARMSREACH)
			wpnpos.y = -DOSO_ARMSREACH;
		
		if(wpnpos.z> DOSO_ARMSREACH)
			wpnpos.z = DOSO_ARMSREACH;
		if(wpnpos.z< -DOSO_ARMSREACH)
			wpnpos.z = -DOSO_ARMSREACH;
		
		if(wpnangle.x> DOSO_MAXANGLE)
			wpnangle.x = DOSO_MAXANGLE;
		if(wpnangle.x< -DOSO_MAXANGLE)
			wpnangle.x = -DOSO_MAXANGLE;
		
		if(wpnangle.y> DOSO_MAXPITCH)
			wpnangle.y = DOSO_MAXPITCH;
		if(wpnangle.y< DOSO_MINPITCH)
			wpnangle.y = DOSO_MINPITCH;
	}
	
	states{
	spawn:
		TNT1 A -1;
		stop;
	select:
		TNT1 A 0 {
			invoker.child = doso_weap_w.create(invoker.worldwpn,invoker);
			invoker.wpnangle = invoker.initangle;
			invoker.wpnpos = invoker.initpos;
		}
		TNT1 A 1 A_Raise();
		wait;
	deselect:
		TNT1 A 0 {
			invoker.child.destroy();
		}
		TNT1 A 1 A_Lower();
		wait;
	ready:
		TNT1 A 1 A_WeaponReady(WRF_NOFIRE);
		loop;
	fire:
		TNT1 A 0;
		goto ready;
	}
}

//base class from which held weapons in-world will inherit
class doso_weap_w:actor abstract{
	//here goes property variables and defaults
	double wpnmass;	//mass in kg
	uint8 massdist;	//how far out of 255 along the weapon's length the center of mass is
	
	uint8 bladecov;	//how much out of 255 of the weapon that is bladed (from the tip to the hands)
	uint8 bladestrt;//if non-zero, where the blade part of the weapon starts (from the tip to the hands)
	
	//note for sharpness: haft is considered to be 0.15 sharpness, which would need considerable force to wound.
	double tipsharp;//how sharp the tip of the weapon is. if 0, deemed to be unable to wound; if 1, deemed to be *very* thin/sharp
	double bldsharp;//how sharp the blade is. if 0, deemed to be blunt and unable to wound; if 1, deemed to be very fine and sharp
	
	uint wpnsize;	//length of the weapon in doom map units
	uint wpnwidth;	//width of the weapon, of course, in doom map units
	uint bladewidth;//width of the weapon's bladed segment, again in dmu
	
	uint8 maxextend;//how much farther beyond arm's length the weapon can be extended
	float restdist;	//how far from the player the weapon rests
	
	name wpnsprite;	//pretty self explanatory. weapons can change these on the fly if they really want to.
	
	property mass:wpnmass,massdist;
	property blade:bladecov,bladewidth;
	property bladestart:bladestrt;
	property size:wpnsize,wpnwidth;
	property sharpness:tipsharp,bldsharp;
	property maxextend:maxextend;
	property restdistance:restdist;
	property sprite:wpnsprite;
	
	default{
		+INTERPOLATEANGLES
		+FLATSPRITE
		+ROLLSPRITE
		+NOCLIP
		+NOGRAVITY
		
		//doso_weap_w defaults
		//default is basically a brick
		doso_weap_w.mass 1.0,128;
		doso_weap_w.blade 0,8;
		doso_weap_w.bladestart 0;
		doso_weap_w.size 24,8;
		doso_weap_w.sharpness 0.15,0.15;
		doso_weap_w.maxextend 1;
		doso_weap_w.restdistance 0;
		doso_weap_w.sprite 'tnt1';
	}
	
	//here goes logic variables and code
	doso_weap parent;
	halfsworder owner;
	
	static doso_weap_w Create(class<doso_weap_w> classname,doso_weap parent){
		doso_weap_w this = doso_weap_w(spawn(classname,parent.owner.pos + (0.0, 0.0, parent.owner.height/2),ALLOW_REPLACE));
		this.parent = parent;
		this.owner = halfsworder(parent.owner);
		this.angle = parent.owner.angle;
		this.pitch = parent.owner.pitch;
		this.changesprite();
		return this;
	}
	
	//map units per tic squared at 1kg
	const POS_MAXACCEL = 3;
	//degrees per tic squared at 1kg and radius 32 (something like one meter)
	const ANG_MAXACCEL = 10.0;
	//velocities multiplied by these every tic
	const P_DECCEL_COEFF = 0.7;
	const A_DECCEL_COEFF = 0.85;
	
	vector3 desired_position;
	double desired_angle;
	double desired_pitch;
	
	vector2 vel_angle;
	
	override void Tick(){
		super.tick();
		
		//spawn the marker at the desired position
		doso_marker.create(restdist,parent);
		
		//set the desired position and angle
		vector2 rotofs = RotateVector(parent.wpnpos.xy + (8.0 + restdist, 0.0),owner.angle);
		vector3 wpnofs = (rotofs.x, rotofs.y, parent.wpnpos.z);
		desired_position = owner.pos + (0.0, 0.0, owner.height/2) + wpnofs;
		
		desired_angle = normalize180(owner.angle + parent.wpnangle.x);
		desired_pitch = parent.wpnangle.y;
		//I wanted to affect the roll to fix the issue of the weapon not quite looking like it's directed toward the
		//line in front of the player but roll doesn't work as I expected it to here so whatever
		
		//now to actually accelerate towards this desired state
		
		//first accelerate pos
		vel *= P_DECCEL_COEFF;
		if(level.vec3diff(pos,desired_position).length()>1){
			double force = POS_MAXACCEL;
			if(wpnmass!=0)
				force /= wpnmass;
			//console.printf("vec to desired pos is "..level.vec3diff(pos,desired_position));
			//turn this vector into a unit vector and then multiply it by POS_MAXACCEL
			vector3 movevec = level.vec3diff(pos,desired_position);
			if(movevec.length()<(force/P_DECCEL_COEFF)*2){
				float dist = movevec.length();
				dist /= (force/P_DECCEL_COEFF)*2;
				force *= dist;
			}
			movevec /= movevec.length();
			movevec *= force;
			vel += movevec;
		}
		
		//then accelerate angle
		vel_angle *= A_DECCEL_COEFF;
		//here we have to do some more fancy stuff, involving moment of inertia and torque.
		//torque is simply going to be our initial acceleration assuming MoI of one.
		//we will be doing a very crude approximation by simply multipliying mass by radius squared.
		//hopefully this works well enough.
		if((deltaangle(angle,desired_angle),deltaangle(pitch,desired_pitch)).length()>6){
			double torque = ANG_MAXACCEL;
			//we divide CoM radius by 32 to get it in something resembling meters.
			double comradius = (wpnsize*(massdist/255.0)/32);
			double momentinertia = wpnmass * comradius * comradius;
			if(momentinertia!=0)
				torque /= momentinertia;
			else
				console.printf("moment of inertia for weapon is zero!");
			vector2 movevec = (deltaangle(angle,desired_angle),deltaangle(pitch,desired_pitch));
			if(movevec.length()<(torque/A_DECCEL_COEFF)*8){
				float dist = movevec.length();
				dist /= (torque/A_DECCEL_COEFF)*8;
				torque *= dist;
			}
			movevec /= movevec.length();
			movevec *= torque;
			vel_angle += movevec;
		}
		angle += vel_angle.x;
		pitch += vel_angle.y;
	}
	
	void ChangeSprite(name spritename = "null"){
		if(spritename=="null"){
			spritename = default.wpnsprite;
		}
		wpnsprite = spritename;
		sprite = GetSpriteIndex(wpnsprite);
	}
	
	states{
	spawn:
		#### Z 1;
		loop;
	}
}


//desired position marker
class doso_marker:actor{
	default{
		+INTERPOLATEANGLES
		+FLATSPRITE
		+ROLLSPRITE
		+NOCLIP
		+NOGRAVITY
		
		//+BRIGHT
		
		renderstyle "add";
		alpha 0.5;
	}
	
	static void Create(float restdist,doso_weap parent){
	restdist-=1;
		vector2 rotofs = RotateVector(parent.wpnpos.xy + (8.0 + restdist, 0.0),parent.owner.angle);
		vector3 wpnofs = (rotofs.x, rotofs.y, parent.wpnpos.z+1);
		doso_marker this = doso_marker(spawn("doso_marker",parent.owner.pos + (0.0, 0.0, parent.owner.height/2) + wpnofs,ALLOW_REPLACE));
		
		this.angle = parent.owner.angle + parent.wpnangle.x;
		this.pitch = parent.wpnangle.y;
	}
	
	states{
	spawn:
		LINE Y 2;
		stop;
	}
}