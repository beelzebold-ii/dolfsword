// ABSTRACT BASE CLASSES FOR WEAPONS AND WORLDWEAPONS
//~===================================================~

//how far your arms can reach, in map units
const DOSO_ARMSREACH = 18;
//maximum yaw deviation from front of your weapon
const DOSO_MAXANGLE = 115.0;
//lowest pitch of your weapon
const DOSO_MAXPITCH = 85.0;
//highest pitch of your weapon
const DOSO_MINPITCH =-135.0;

//base class from which weapon items will inherit
class doso_weap:weapon abstract{
	class<doso_weap_w> worldwpn;	//the world weapon to spawn in world!
	
	vector2 initangle;	//the readied angle to initialize to
	vector3 initpos;	//the readied position to initialize to
	
	property world:worldwpn;
	property angle:initangle;
	property pos:initpos;
	
	default{
		doso_weap.world "doso_weap_w";
		//angle and pos of all zero is considered to be straight ahead and pointed out; ie, a fuck-off stance
		doso_weap.angle (0.0, 0.0);
		doso_weap.pos (0.0, 0.0, 0.0);
	}
	
	doso_weap_w child;
	vector2 wpnangle;
	vector3 wpnpos;
	
	const SENS_SWINGTRA = 0.3;
	const SENS_SWINGANG = 1.6;
	const SENS_MOVE		= 0.5;
	const SENS_ROTATE	= 1.0;
	
	void rotatew(float x,float y){
		wpnangle -= (x*SENS_ROTATE,y*SENS_ROTATE);
		
		boundw();
	}
	void swingw(float x,float y){
		wpnpos += (0.0,-x*SENS_SWINGTRA,y*SENS_SWINGTRA);
		wpnangle -= (x*SENS_SWINGANG,y*SENS_SWINGANG);
		
		boundw();
	}
	void movew(float x,float y){
		wpnpos += (y*SENS_MOVE,-x*SENS_MOVE,0.0);
		
		boundw();
	}
	
	//ensure the weapon is within its allowed boundries
	void boundw(){
		if(wpnpos.x< -(child.maxextend))
			wpnpos.x = -(child.maxextend);
		if(wpnpos.x> DOSO_ARMSREACH + (child.maxextend))
			wpnpos.x = DOSO_ARMSREACH + (child.maxextend);
		
		if(wpnpos.y> DOSO_ARMSREACH)
			wpnpos.y = DOSO_ARMSREACH;
		if(wpnpos.y< -DOSO_ARMSREACH)
			wpnpos.y = -DOSO_ARMSREACH;
		
		if(wpnpos.z> DOSO_ARMSREACH)
			wpnpos.z = DOSO_ARMSREACH;
		if(wpnpos.z< -DOSO_ARMSREACH)
			wpnpos.z = -DOSO_ARMSREACH;
		
		if(wpnangle.x> DOSO_MAXANGLE)
			wpnangle.x = DOSO_MAXANGLE;
		if(wpnangle.x< -DOSO_MAXANGLE)
			wpnangle.x = -DOSO_MAXANGLE;
		
		if(wpnangle.y> DOSO_MAXPITCH)
			wpnangle.y = DOSO_MAXPITCH;
		if(wpnangle.y< DOSO_MINPITCH)
			wpnangle.y = DOSO_MINPITCH;
	}
	
	states{
	spawn:
		TNT1 A -1;
		stop;
	select:
		TNT1 A 0 {
			invoker.child = doso_weap_w.create(invoker.worldwpn,invoker);
			invoker.wpnangle = invoker.initangle;
			invoker.wpnpos = invoker.initpos;
		}
		TNT1 A 1 A_Raise();
		wait;
	deselect:
		TNT1 A 0 {
			invoker.child.destroy();
		}
		TNT1 A 1 A_Lower();
		wait;
	ready:
		TNT1 A 1 A_WeaponReady(WRF_NOFIRE);
		loop;
	fire:
		TNT1 A 0;
		goto ready;
	}
}

//base class from which held weapons in-world will inherit
class doso_weap_w:actor abstract{
	//here goes property variables and defaults
	double wpnmass;	//mass in kg
	uint8 massdist;	//how far out of 255 along the weapon's length the center of mass is
	
	uint8 bladecov;	//how much out of 255 of the weapon that is bladed (from the tip to the hands)
	uint8 bladestrt;//if non-zero, where the blade part of the weapon starts (from the tip to the hands)
	
	//note for sharpness: haft is considered to be 0.15 sharpness, which would need considerable force to wound.
	double tipsharp;//how sharp the tip of the weapon is. if 0, deemed to be unable to wound; if 1, deemed to be *very* thin/sharp
	double bldsharp;//how sharp the blade is. if 0, deemed to be blunt and unable to wound; if 1, deemed to be very fine and sharp
	
	uint wpnsize;	//length of the weapon in doom map units
	uint wpnwidth;	//width of the weapon, of course, in doom map units
	uint bladewidth;//width of the weapon's bladed segment, again in dmu
	
	uint8 maxextend;//how much farther beyond arm's length the weapon can be extended
	float restdist;	//how far from the player the weapon rests
	
	name wpnsprite;	//pretty self explanatory. weapons can change these on the fly if they really want to.
	
	property mass:wpnmass,massdist;
	property blade:bladecov,bladewidth;
	property bladestart:bladestrt;
	property size:wpnsize,wpnwidth;
	property sharpness:tipsharp,bldsharp;
	property maxextend:maxextend;
	property restdistance:restdist;
	property sprite:wpnsprite;
	
	default{
		+INTERPOLATEANGLES
		+FLATSPRITE
		+ROLLSPRITE
		+NOCLIP
		+NOGRAVITY
		
		//doso_weap_w defaults
		doso_weap_w.mass 1.0,128;
		doso_weap_w.blade 0,8;
		doso_weap_w.bladestart 0;
		doso_weap_w.size 24,8;
		doso_weap_w.sharpness 0.15,0.15;
		doso_weap_w.maxextend 1;
		doso_weap_w.restdistance 0;
		doso_weap_w.sprite 'tnt1';
	}
	
	//here goes logic variables and code
	doso_weap parent;
	halfsworder owner;
	
	static doso_weap_w Create(class<doso_weap_w> classname,doso_weap parent){
		doso_weap_w this = doso_weap_w(spawn(classname,parent.owner.pos + (0.0, 0.0, parent.owner.height/2),ALLOW_REPLACE));
		this.parent = parent;
		this.owner = halfsworder(parent.owner);
		this.angle = parent.owner.angle;
		this.pitch = parent.owner.pitch;
		this.changesprite();
		return this;
	}
	
	override void Tick(){
		super.tick();
		vector2 rotofs = RotateVector(parent.wpnpos.xy + (8.0 + restdist, 0.0),owner.angle);
		vector3 wpnofs = (rotofs.x, rotofs.y, parent.wpnpos.z);
		SetOrigin(owner.pos + (0.0, 0.0, owner.height/2) + wpnofs, true);
		
		angle = normalize180(owner.angle + parent.wpnangle.x);
		pitch = parent.wpnangle.y;
		//I wanted to affect the roll to fix the issue of the weapon not quite looking like it's directed toward the
		//line in front of the player but roll doesn't work as I expected it to here so whatever
	}
	
	void ChangeSprite(name spritename = "null"){
		if(spritename=="null"){
			spritename = default.wpnsprite;
		}
		wpnsprite = spritename;
		sprite = GetSpriteIndex(wpnsprite);
	}
	
	states{
	spawn:
		#### Z 1;
		loop;
	}
}